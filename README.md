# Project-impl-sm2-with-RFC6979
该仓库中的代码完成了如下project
按协议RFC6979实现SM2。
应用该sm2 class，可以在真实网络通信环境下实现sm2 的2部分签名过程！
在真实网络通信环境下实现sm2 的2部分解密过程。！


**一、ECDSA概述**
 
  椭圆曲线数字签名算法（ECDSA）是使用椭圆曲线密码（ECC）对数字签名算法（DSA）的模拟。与普通的离散对数问题（DLP）和大数分解问题（IFP）不同，椭圆曲线离散对数问题没有亚指数时间的解决方法。因此椭圆曲线密码的单位比特强度要高于其他公钥体制。
数字签名算法（DSA）在联邦信息处理标准FIPS中有详细论述，称为数字签名标准。它的安全性基于素域上的离散对数问题。可以看作是椭圆曲线对先前离散对数问题（DLP）的密码系统的模拟，只是群元素由素域中的元素数换为有限域上的椭圆曲线上的点。椭圆曲线离散对数问题远难于离散对数问题，单位比特强度要远高于传统的离散对数系统。因此在使用较短的密钥的情况下，ECC可以达到于DL系统相同的安全级别。这带来的好处就是计算参数更小，密钥更短，运算速度更快，签名也更加短小。【1】

**二、ECDSA原理【2】**

  ECDSA是ECC与DSA的结合，整个签名过程与DSA类似，所不一样的是签名中采取的算法为ECC，最后签名出来的值也是分为r,s。
签名过程如下：
1、选择一条椭圆曲线Ep(a,b)，和基点G；

2、选择私有密钥k（k<n，n为G的阶），利用基点G计算公开密钥K=kG；

3、产生一个随机整数r（r<n），计算点R=rG；

4、将原数据和点R的坐标值x,y作为参数，计算SHA1做为hash，即Hash=SHA1(原数据,x,y)；

5、计算s≡r - Hash * k (mod n)

6、r和s做为签名值，如果r和s其中一个为0，重新从第3步开始执行

验证过程如下：

1、接受方在收到消息(m)和签名值(r,s)后，进行以下运算

2、计算：sG+H(m)P=(x1,y1), r1≡ x1 mod p。

3、验证等式：r1 ≡ r mod p。

4、如果等式成立，接受签名，否则签名无效。

**三.SM2加密与签名认证**

  SM2算法是国家密码管理局于2010年12月颁布的中国商用公钥密码标准算法。SM2基于椭圆曲线离散对数问题，计算复杂度是指数级（暂未发现亚指数级或多项式级的计算方法），相较于广泛应用的RSA公钥密码算法，在同等安全程度要求下，SM2所需密钥长度小、处理速度快。由于SM2在安全性、运算性能等方面都优于RSA算法，且具有自主知识产权，我国计划在商用密码体系中用SM2替换RSA算法。【3】椭圆曲线密码（ECC）的安全性明显强于RSA，该结论参考知乎用户@Datacruier,列出对比表格。
  
![图片](https://user-images.githubusercontent.com/107350922/179737106-c120bb2b-482b-4171-a516-0642fda49778.png)
![图片](https://user-images.githubusercontent.com/107350922/179737130-355099e0-4b29-4155-8373-c6ae89f393a1.png)

  在依据RFC6979规定的标准，对于SM2方案的实现采用Python语言编写的国密工具包主要是gmssl-python库和snowland-smx-python（pysmx）库，二者较为完整地实现了SM2、SM3、SM4等国密算法。本工具包涉及的散列运算使用了pysmx库的SM3算法，pysmx库对SM3算法的实现高效而优雅，在此向pysmx库的作者致以诚挚的敬意和感谢！

相较于现有Python国密算法工具包的SM2模块，本工具包的优势主要体现在以下3个方面：

1. 首次开源SM2密钥协商算法。gmssl库和pysmx库仅实现了SM2签名和验证、加密和解密算法，没有实现SM2密钥协商算法，互联网上也未找到实现SM2密钥协商算法的Python代码，故本工具包是首次在互联网上开源SM2密钥协商算法的Python代码。【4】

2. 算法实现更为健壮和完整。gmssl库和pysmx库中的椭圆曲线点乘算法仅能输入有限域内的乘数（否则报错），所实现的SM2签名/验证算法不包含标准要求的Z值计算和Hash变换，除核心算法（密钥生成、签名、验证、加密、解密等）之外还缺少标准描述的一些辅助算法，gmssl库仅能输入bytes类型消息；本工具包的点乘算法能够输入任意自然数作为乘数并保证正确性，SM2签名/验证算法完整实现了Z值计算和Hash变换，除核心算法之外还实现了标准描述的一些重要辅助函数（如公钥验证、椭圆曲线系统参数验证等）。

3. 性能更佳。本工具包通过采用更高效的点乘算法、减少数据类型转换、充分运用算术运算加速技巧等途径，明显提高了计算效率。以SM2算法耗时的主要来源——椭圆曲线点乘运算为例进行测试，同等条件下本工具包的平均耗时约为gmssl库的35.5%、pysmx库的61.8%，实际运行签名与验证、加解密等算法同样具备上述幅度的性能优势。【5】

**四.实现sm2加密方案的理论依据**

加密过程：
  设需要发送的消息为比特串 M ，klen 为 M 的比特长度。
    
  为了对明文 M 进行加密，作为加密者的用户 A 应实现以下运算步骤：
    
 1：用随机数发生器产生随机数k∈[1,n-1]；
    
 2：计算椭圆曲线点 C1=[k]G=(x1,y1)，（[k]G 表示 k*G ）将C1的数据类型转换为比特串；
    
 3：计算椭圆曲线点 S=[h]PB，若S是无穷远点，则报错并退出；
    
 4：计算椭圆曲线点 [k]PB=(x2,y2)，将坐标 x2、y2 的数据类型转换为比特串；
    
 5：计算t=KDF(x2 ∥ y2, klen)，若 t 为全0比特串，则返回 A1；
    
 6：计算C2 = M ⊕ t；
    
 7：计算C3 = Hash(x2 ∥ M ∥ y2)；
    
 8：输出密文C = C1 ∥ C2 ∥ C3。
    
解密过程：

   设klen为密文中C2的比特长度。
    
   为了对密文C=C1 ∥ C2 ∥ C3 进行解密，作为解密者的用户 B 应实现以下运算步骤：
    
   1：从C中取出比特串C1，将C1的数据类型转换为椭圆曲线上的点，验证C1是否满足椭圆曲线方程，若不满足则报错并退出；
    
   2：计算椭圆曲线点 S=[h]C1，若S是无穷远点，则报错并退出；
    
   3：计算[dB]C1=(x2,y2)，将坐标x2、y2的数据类型转换为比特串；
    
   4：计算t=KDF(x2 ∥ y2, klen)，若t为全0比特串，则报错并退出；
    
   5：从C中取出比特串C2，计算M′ = C2 ⊕ t；
    
   6：计算u = Hash(x2 ∥ M′ ∥ y2)，从C中取出比特串C3，若u != C3，则报错并退出；
   
   7：输出明文M′。
    
原理：

  用户 A 持有公钥PB=[dB]G（仅有PB值），用户 B 持有私钥 dB
     
  加密：C1=k*G  C2=M⊕(k*PB)      解密：M′=C2 ⊕ (dB*C1)     # 这里只叙述基本原理，便于理解
     
  证明：dB*C1=dB*k*G=k*(dB*G)=k*PB  因此，M′=C2 ⊕ (dB*C1)=M⊕(k*PB)⊕(k*PB)=M  得证
 
注：此实现算法所研究的椭圆曲线是基于域 Fp 上的椭圆曲线【7】

**五.实现sm2数字签名的理论依据**

密钥生成算法

Alice选择随机数dA做为私钥，其中0

Alice计算公钥PA=dA⋅G

输出密钥对 (sk=dA, pk=PA)
签名算法

设Alice发签名消息M给Bob，IDA是Alice的标识符，ENTLA是IDA的长度，dA是A的私钥，基点G= (xG, yG)，A的公钥PA=dA ⋅ G= (xA, yA).。

ZA=H (ENTLA ‖IDA ‖a‖b‖ xG ‖ yG ‖ xA ‖ yA)， H是SM3算法 

①设置M*=ZA ‖M并计算 e = H(M*)

②产生随机数k∈[1, n-1]

③计算椭圆曲线点G1=k ⋅ G= (x1, y1)

④计算r=(e+x1) mod n，若r=0或r+k=n则返回② 

⑤计算s=(1+ dA)−1·(k −r ·dA)mod n，若s=0则返回②

⑥以(r, s)作为对消息M的签名

![图片](https://user-images.githubusercontent.com/107350922/180209008-0a9bdf52-f795-4d0f-a518-adb8c80f275a.png)
【8】

验证算法

接收到的消息为M′，签名为(r′, s′)和发送者Alice的公钥PA，Bob执行如下步骤验证合法性：

检验r′∈[1, n-1]是否成立，若不成立则验证不通过

检验s′∈[1, n-1]是否成立，若不成立则验证不通过

设置M*=ZA‖M′ 

计算e′= H(M* )

计算t= (r′ + s′) mod n，若t=0，则验证不通过

计算椭圆曲线点 (x1′，y1′)= s′ · G + t · PA

计算v=(e′+ x1′) mod n，检验v=r′是否成立，若成立则验证通过；否则验证不通过

![图片](https://user-images.githubusercontent.com/107350922/180209065-cc1d9ef9-a35a-4395-b0ab-4151eb9c035e.png)
【8】

**六.代码文件说明：**

complete submission是所有工作量的集合版，由于是分功能实现SM2相关的部件，所以进行的了分块的提交。
 
首先对于SM体系下的椭圆曲线加解密体系，实现了一个ECC—class,椭圆曲线密码类（实现一般椭圆曲线的运算，不局限于SM2）。该实现思路参考【6】。

对于SM2-class，则是调用了ECC—class作为底层运算部件，根据RFC6979协议标准实现。该方案进行了基础性的ECDH正确性测试，SM2密钥协商测试，SM2数字签名与验证测试，测试过程均在key-Enc-test文件中可运行。

最后main_part运行结果，可复现RFC6979，SM2文档中的示例结果（达到要求）

备注：若要完整运行测试代码还需安装gmssl（pip install gmssl）和pysmx（pip install snowland-smx）。

**参考文献：**
【1】：https://zhuanlan.zhihu.com/p/455030060

【2】：https://zhuanlan.zhihu.com/p/442141489

【3】：https://baike.baidu.com/item/SM2/15081831?fr=aladdin

【4】：https://zhuanlan.zhihu.com/p/347750862

【5】：国家密码管理局关于发布《SM2椭圆曲线公钥密码算法》公告[EB/OL]．(2010-12-17) [2022-02-20]．https://sca.gov.cn/sca/xwdt/2010-12/17/content_1002386.shtml．

【6】：https://gitee.com/basddsa/hggm

【7】：https://blog.csdn.net/chexlong/article/details/103293311

【8】：https://blog.51cto.com/u_14793075/5307999

